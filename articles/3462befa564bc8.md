---
title: "Recoilの階層的なkey管理とMapped Types、Conditional Types"
emoji: "🔑"
type: "tech"
topics: ["recoil", "typescript"]
published: false
---

## Recoil

React用の状態管理ライブラリとして、[Recoil](https://recoiljs.org/)というMeta（旧Facebook）が開発中の比較的新しいライブラリがあります。
記事執筆時点での最新バージョンはまだv0.6.1で"experimental"という位置づけですが、記事執筆時点でGitHubのスター数は約16,000あり、巷でも最近よく名前を聞くようになってきたと個人的には感じます。

Recoilでは状態のソースを`atom`として定義します。さらにatomの値をもとに（純粋な関数によって）計算可能な値を`selector`として定義することもできます。同様に他のselectorの値をもとにして計算可能な値もまたselectorとして定義できます。

Recoilの基本的なAPIの使い方等は公式ドキュメントの[チュートリアル](https://recoiljs.org/docs/basic-tutorial/intro)などを参照していただくとして、Recoilを使ったアプリケーションでは上記の小さなatomやselectorが複数あり、各Reactコンポーネント内では特定のatomの状態を更新したり所望のatomやselectorの値を購読したりする、というのが基本的なコンセプトになります。

## Atom、Selectorにおける`key`

Recoilのatomとselectorを定義する際、人間が`key`を指定する必要があります。公式ドキュメントの["Getting Started"](https://recoiljs.org/docs/introduction/getting-started)のコード例を以下に引用します:

```ts
const textState = atom({
  key: 'textState', // unique ID (with respect to other atoms/selectors)
  default: '', // default value (aka initial value)
});

const charCountState = selector({
  key: 'charCountState', // unique ID (with respect to other atoms/selectors)
  get: ({get}) => {
    const text = get(textState);

    return text.length;
  },
});
```

コメントにも書いてありますが、これらの`key`はアプリケーション全体を通じて他のatomやselectorに対して一意でなければならないという制約があります。この制約を人間側が頑張って担保しようとするのは明らかに無理があるので、何らかの方法でTypeScriptのコンパイラに任せたいところです。

### enumによる管理戦略

こちらの[ブログ記事](https://engineering.linecorp.com/ja/blog/line-sec-frontend-using-recoil-to-get-a-safe-and-comfortable-state-management/)ではkeyを一元管理するファイルを作成し、enumを用いて制約を保証する手法が紹介されていました。以下にコードを引用します:

```ts:RecoilKeys.ts
export enum RecoilAtomKeys {
  TODO_STATE = 'todoState',
  NOTICE_STATE = 'noticeState'
}
​
export enum RecoilSelectorKeys {
  TODO_TODOS = 'Todo_todos',
  TODO_TODO_ITEM = 'Todo_todoItem',
  NOTICE_HAS_UNREAD_NOTICE = 'Notice_hasUnreadNotice'
}
```

これは確かに良さそうな方法ですね。

### `key`のprefixを自動で付けたい

上記のenumを用いる管理法は良さそうですが、keyどうしを区別するためのprefixまで含めて直接記載しているので、keyの数が増えていったときに少しだけ見た目が読みにくくなってしまいそうな気もします（個人の感想です）。また、まず無いとは思いますがprefixの部分をついうっかり書き間違えてしまう可能性も無くはありません。

```ts:RecoilKeys.ts
export enum RecoilAtomKeys {
  TODO_STATE = "todoState",
  NOTICE_STATE = "noticeState",
}

export enum RecoilSelectorKeys {
  TODO_TODOS = "Todo_todos",
  TODO_TODO_ITEM = "Todo_todoItem",
  TODO_DONE_ITEM = "Todo_doneItem",
  TODO_DEADLINE_OVER_ITEM = "Todo_deadlineOverItem",
  // ...
  NOTICE_HAS_UNREAD_NOTICE = "Notice_hasUnreadNotice",
  NOTICE_FAVORITE_NOTICE = "Noticee_favoriteNotice",
  // ...
}
```

これを例えば、オブジェクトの形式で書くようにして、プロパティ名が名前空間的な役割を持ち、葉となるプロパティの値はそれまでのprefixを自動で受け継いでくれるようにできないでしょうか……

```ts:RecoilKeys.ts
// 仮のイメージです
export const RecoilAtomKeys = {
  todo: {
    state: "TodoState",
  },
  notice: {
    state: "NoticeState",
  },
};

// 仮のイメージです
export const RecoilSelectorKeys = {
  todo: {
    todos: "TodoTodos",
    todoItem: "TodoTodoItem",
    doneItem: "TodoDoneItem",
    deadlineOverItem: "TodoDeadlineOverItem",
    // ...
  },
  notice: {
    hasUnreadNotice: "NoticeHasUnreadNotice",
    favoriteNotice: "NoticeFavoriteNotice",
    // ...
  },
};
```

というようなことを思ったので、以下のような`addPrefix`という簡単な関数を書いてみました:

```ts
const addPrefix = <Prefix extends string, Keys extends Record<string, unknown>>(
  prefix: Prefix,
  keys: Keys
): Record<string, unknown> => {
  return Object.fromEntries(
    Object.entries(keys).map(([key, value]) => {
      const capitalKey = `${key.charAt(0).toUpperCase()}${key.slice(1)}`;

      if (typeof value === "string") {
        return [key, `${prefix}${capitalKey}`];
      } else {
        return [
          key,
          addPrefix(`${prefix}${capitalKey}`, value as Record<string, unknown>),
        ];
      }
    })
  );
};
```

`addPrefix`は`prefix`および管理したいkeyたちが定義された`keys`オブジェクトを受け取り、再帰的に`prefix`を付けてCamelCaseにしつつ返します。

`keys`の階層の深さは任意なので引数の型としては`Keys extends Record<string, unknown>`としました。そして戻り値型も素朴に考えると`Record<string, unknown>`となります（が、これについては後述します）。

この`addPrefix`を使うと`RecoilAtomKeys`や`RecoilSelectorKeys`は例えば以下のように書くことができます:

```ts
export const RecoilAtomKeys = addPrefix("", {
  todo: {
    state: "state",
  },
  notice: {
    state: "state",
  },
});

export const RecoilSelectorKeys = addPrefix("", {
  todo: {
    todos: "todos",
    todoItem: "todoItem",
    doneItem: "doneItem",
    deadlineOverItem: "deadlineOverItem",
    // ...
  },
  notice: {
    hasUnreadNotice: "hasUnreadNotice",
    favoriteNotice: "favoriteNotice",
    // ...
  },
});
```
